## 면접 기초 질문

### 1.1. 변수와 데이터 타입

- **변수란 무엇인가요?**
 - 변수는 데이터를 저장하는 공간으로, 메모리에서 특정 위치를 참조합니다. 변수를 선언할 때 그 타입을 지정해야 하며, 이 타입은 변수에 저장될 수 있는 데이터의 종류를 결정합니다.

- **정수형, 실수형, 문자열의 차이점은 무엇인가요?**
  - 정수형 (int): 정수 값을 저장합니다 (예: 5, -10)
  - 실수형 (float, double): 소수점을 포함한 실수 값을 저장합니다 (예: 3.14, -0.001)
  - 문자열 (char array 또는 string): 문자의 나열로 구성된 데이터입니다 (예: "Hello", 'A')

- **C에서 포인터란 무엇인가요?**
 - 포인터는 메모리의 주소를 저장하는 변수입니다. 변수의 값을 직접 사용하는 대신, 포인터를 통해 변수의 메모리 주소를 참조하여 값을 변경하거나 읽을 수 있습니다.

### 1.2. 조건문 및 반복문

- **if문과 switch문을 언제 사용하나요?**
  - `if문`: 특정 조건을 평가하고, 조건이 참일 경우 실행됩니다. 여러 조건을 연쇄적으로 평가할 때 유용합니다.
  - `switch문`: 하나의 변수에 대해 여러 경우를 비교하고 각각에 대해 특정 코드를 실행합니다. 여러 `if-else`를 대체할 수 있습니다.

- **for문과 while문의 차이점은 무엇인가요?**
  - `for문`: 반복 횟수가 미리 정해져 있을 때 사용합니다. 초기화, 조건식, 증감식을 한 줄로 표현할 수 있어 코드가 간결합니다.
  - `while문`: 반복 횟수가 미리 정해지지 않은 경우, 조건식이 참인 동안 반복합니다.

### 1.3. 함수

- **함수의 정의와 호출 방법에 대해 설명해주세요.**
 - 함수는 특정 작업을 수행하는 코드 블록으로, 입력값을 받고 결과를 반환할 수 있습니다. 함수는 반환타입 `함수이름(매개변수)` 형식으로 정의되며, 호출 시에는 함수 이름과 괄호 안에 인수를 전달합니다.

- **재귀 함수가 무엇인지 설명해주세요.**
-  재귀 함수는 자기 자신을 호출하는 함수입니다. 문제를 더 작은 문제로 나누어 해결하는 방식으로, 종료 조건을 명확히 설정해야 무한 호출을 방지할 수 있습니다.

### 1.4. 배열 및 문자열

- **배열과 리스트의 차이점은 무엇인가요?**
  - 배열: 고정된 크기의 연속적인 메모리 공간에 데이터를 저장하며, 크기가 고정되어 변경할 수 없습니다.
  - 리스트: 동적으로 크기가 변경될 수 있는 데이터 구조로, 크기를 쉽게 확장하거나 축소할 수 있습니다. C에서는 배열을 사용하며, 리스트는 보통 동적 메모리 할당과 관련된 구조입니다.

- **문자열의 끝을 어떻게 구분하나요?**
 - C에서 문자열은 null terminator(문자열의 끝을 나타내는 `\0`)로 끝을 구분합니다.

### 1.5. 객체 지향 개념 (OOP)

- **객체 지향 프로그래밍의 4대 특징은 무엇인가요?**
  - 캡슐화: 데이터를 보호하고, 데이터에 접근할 수 있는 방법을 제한하는 개념.
  - 상속: 기존 클래스의 기능을 새로운 클래스가 물려받아 사용하는 개념.
  - 다형성: 동일한 함수 이름이지만 서로 다른 방식으로 동작하는 특성.
  - 추상화: 복잡한 구현 세부사항을 숨기고 중요한 기능만 노출시키는 개념.

## 2. 알고리즘 및 자료구조

### 2.1. 정렬 알고리즘

- **버블 정렬, 선택 정렬, 삽입 정렬에 대해 설명해주세요.**
  - **버블 정렬**: 인접한 두 원소를 비교하여 순서가 잘못된 경우 교환하는 방식으로, 가장 큰 값을 끝으로 밀어내며 정렬합니다. 시간 복잡도는 `O(n^2)`입니다.
  - **선택 정렬**: 주어진 배열에서 가장 작은 원소를 찾아 첫 번째 원소와 교환하고, 그 다음으로 가장 작은 원소를 찾는 방식입니다. 시간 복잡도는 `O(n^2)`입니다.
  - **삽입 정렬**: 현재 원소를 적절한 위치에 삽입하여 정렬하는 방식입니다. 최악의 경우 시간 복잡도는 `O(n^2)`, 최선의 경우 `O(n)`입니다.

- **퀵 정렬과 머지 정렬의 차이점은 무엇인가요?**
  - **퀵 정렬**: 분할 정복 방식을 사용하여 배열을 두 개의 부분으로 나누고, 각 부분을 정렬하여 합치는 방식입니다. 평균 시간 복잡도는 `O(n log n)`입니다.
  - **머지 정렬**: 배열을 두 개로 나눈 후 각각을 재귀적으로 정렬하고, 정렬된 두 배열을 병합하는 방식입니다. 시간 복잡도는 `O(n log n)`입니다.

### 2.2. 검색 알고리즘

- **이진 탐색에 대해 설명해주세요.**
 - 이진 탐색은 정렬된 배열에서 값을 찾는 효율적인 알고리즘입니다. 중앙 값을 기준으로 찾고자 하는 값이 왼쪽에 있는지 오른쪽에 있는지를 반복적으로 결정하여 탐색 범위를 절반씩 줄여나갑니다. 시간 복잡도는 `O(log n)`입니다.

- **선형 탐색과 이진 탐색의 차이점은 무엇인가요?**
  - **선형 탐색**: 배열의 처음부터 끝까지 하나씩 비교하는 방식으로, 시간 복잡도는 `O(n)`입니다.
  - **이진 탐색**: 정렬된 배열에서 중앙값을 기준으로 탐색 범위를 절반씩 줄여가며 찾는 방식으로, 시간 복잡도는 `O(log n)`입니다.

### 2.3. 자료구조

- **스택과 큐의 차이점은 무엇인가요?**
  - **스택**: 후입선출(LIFO) 구조로, 마지막에 들어온 데이터가 먼저 나옵니다. 예: 브라우저의 뒤로 가기 기능.
  - **큐**: 선입선출(FIFO) 구조로, 먼저 들어온 데이터가 먼저 나옵니다. 예: 은행의 대기줄.

- **링크드 리스트와 배열의 차이점은 무엇인가요?**
  - **배열**: 고정된 크기의 연속적인 메모리 공간으로 데이터를 저장하며, 인덱스로 빠르게 접근할 수 있습니다.
  - **링크드 리스트**: 각 원소가 이전/다음 원소를 참조하는 포인터를 갖는 동적 데이터 구조로, 크기가 동적으로 변경됩니다.

- **해시맵이 무엇인가요?**
 - 해시맵(혹은 해시 테이블)은 키와 값을 짝지어서 저장하는 자료구조로, 키를 해시 함수로 처리하여 값을 빠르게 찾을 수 있습니다. 평균적인 시간 복잡도는 `O(1)`입니다.

### 2.4. 시간 복잡도 (Big O Notation)

- **O(n), O(log n), O(n^2)의 의미를 설명해주세요.**
  - `O(n)`: 입력 크기 `n`에 비례하여 시간이 걸립니다. 예: 선형 탐색.
  - `O(log n)`: 입력 크기가 커질수록 시간이 조금씩 증가하는 구조입니다. 예: 이진 탐색.
  - `O(n^2)`: 입력 크기 `n`에 대해 제곱에 비례하는 시간 복잡도를 가집니다. 예: 버블 정렬, 선택 정렬.

## 3. 기타 기본적인 질문

- **객체 지향 프로그래밍의 장점은 무엇인가요?**
 - 코드 재사용성, 유지보수 용이성, 확장성, 다형성 지원 등의 장점이 있습니다.

- **Git이 무엇인지 설명해 주세요.**
 - Git은 분산 버전 관리 시스템으로, 소스 코드의 변경 이력을 관리하고 여러 개발자가 협업할 수 있도록 돕습니다.

- **컴퓨터 프로그램의 디버깅 과정에서 주로 사용하는 기법은 무엇인가요?**
 - 디버거 사용, 출력문 추가, 단계별 실행 등을 사용하여 프로그램을 분석하고 버그를 찾습니다.

#

## DataBase
### 관계형 데이터베이스
- 관계형 데이터베이스는 데이터를 테이블 형식으로 저장하고 관리하는 데이터베이스 시스템이다.
- 각 테이블은 행(레코드)과 열(필드)로 구성되며,  
  SQL을 사용하여 데이터를 조직하고 쿼리(Query명령어를 사용하는 작업)한다.
- 데이터의 일관성과 무결성이 중요한 경우에 적합하고 , NoSQL은 확장성과 성능이 필요한 경우에 적합하다.

### 관계형 테이터베이스의 테이블 개념, 행과 열 
- 테이블은 데이터를 저장하는 기본 단위로 행(row)과 열(column)으로 구성되어있다.
- 열 : 데이터의 속성이나 필드를 나타내고 , 각 열은 특정 데이터 유형을 갖는다.
- 행 : 각 속성에 대한 실제 데이터를 담고 있는 개별 레코드를 의미한다.

### 기본 키란?, 관계형 데이터베이스에서 중요한 이유
- 기본 키(Primary Key)는 테이블 내의 각 행의 고유하게 식별하는데 사용되는 하나 이상의 열 이다.
- Null값을 가질 수 없고 중복 될 수 없다.
- 데이터의 무결성을 유지하고, 테이블 간의 관계를 설정하는데 필수이다.
- 기본 키를 통해 빠르고 효율적인 데이터 검색이 가능, 외래 키를 통해 다른 테이블과의 연결을 가능하게 한다.

### 외래 키
- 한 테이블의 열이 다른 테이블의 기본 키를 참조하는 키 이다.
- 외래 키는 테이블 간의 관계를 정의하고, 데이터의 참조 무결성을 유지하는데 사용된다.

### 데이터베이스에서 제약조건의 목적
- 데이터의 무결성과 일관성을 유지하기 위해 사용되는 규칙이다.
- NOT NULL : 열에 NULL 값을 허용하지 않는다.
- UNIQUE : 열의 모든 값이 고유해야한다.
- PRIMARY KEY : NOT NULL, UNIQUE 두 속성을 모두 갖는다. 테이블의 기본키로 사용
- FOREIGN KEY : 다른 테이블의 기본 키를 참조하여 테이블 간의 관계를 유지한다.
- CHECK : 열의 값이 특정 조건을 만족해야 한다.
- DEFAULT : 열의 기본값을 설정한다.



## 인덱스 및 성능
### 관계형 데이터베이스에서의 인덱스
- 테이블의 데이터를 빠르게 검색하기 위한 데이터 구조이다.
- 특정 열에 대한 정보를 별도로 저장하여 데이터 조회 시 전체 테이블을 스캔하지 않고 원하는 데이터를 찾을 수 있다.
- SELECT 쿼리의 성능이 향상된다.

### 클러스터형 인데스와 비클러스터형 인덱스의 차이점
- 클러스터형 인덱스
  - 테이블의 실제 데이터가 인덱스에 따라 정렬되어 저장된다.
  - 한 테이블에 하나만 생성 가능하다.
  - 기본 키로 설정되는 경우가 많다.
- 비 클러스터형 인덱스
  - 인덱스와 실제 데이터가 별도로 저장된다.
  - 하나의 테이블에 여러 개의 비클러스터형 인덱스를 만들 수 있다.
  - 인덱스에는 키 값과 실제 데이터의 주소가 저장된다.
 
### 테이블에서 인덱스의 사용을 피해야하는 경우
- 테이블 변경이 빈번한 테이블 : 삽입, 수정, 삭제 시 인덱스 업데이트로 사용시 성능 저하
- 작인 테이블 : 전체 스캔이 더 빠를 수 있어 인덱스의 사용 이점이 없다.
- 카디널리티가 낮은 열(column) : 중복 값이 많은 열에 인덱스를 생성하면 선택도가 낮아 성능 향상이 미미하다.
- 인덱스가 자주 사용되지 않는 경우 : 인덱스 유지 비용만 증가한다.

 ### 인덱싱은 INSERT 및 UPDATE와 사용시 쓰기 작업에 어떤 영향을 주는가?
- INSERT 작업에 대한 영향
  - 인덱스 업데이터 : 삽입된 데이터가 기존 인덱스를 업데이트 하거나 새로운 인덱스를 생성해야 한다.
   인덱스가 많을수록 이 작업은 더 복잡해지고 시간이 오래 걸릴 수 있다.
  - 성능 저하 : 많은 인덱스를 가진 테이블에 데이터를 삽입할 때는, 삽입 작업이 완료된 후 모든 관련 인덱스를 갱신하는데 추가 시간이 소요돼 삽입 성능을 저하시킬 수 있다.

- UPDATE 작업에 대한 영향
  - 값 변경에 따른 인덱스 갱신 : UPDATE 작업은 기존 데이터의 값을 수정하는데 , 수정된 값이 인덱스에
   포함된 열이라면, 해당 인덱스도 업데이트되어야 한다. 추가적인 수정 비용 발생
  - 인덱스 재구성 : 인덱스된 열의 값이 변경될 때 , 그 값에 따라 인덱스의 구조가 변경될 수 있다.
   이로 인해 인덱스의 일부가 다시 정렬되거나 재구성될 필요가 있을 수 있다.
  - 성능 저하 : UPDATE가 여러 인덱스를 수정해야 할 경우에 성능 저하가 될 수 있고, 자주 업데이트 되는
  열에 인덱스를 설정하는 것은 불필요한 성능 문제를 초래할 수 있다. 


## 트렌젝션
### 관계형 데이터베이스에서 트랜잭션이란 무엇인가?
- 데이터베이스에서 논리적인 작업의 단위로, 인련의 데이터베이스 연산을 하나로 묶어 처리한다.
- 트렌젝션은 모두 성공적으로 완료되거나(Commit), 모두 취소되어 이전 상태(Rollback)로 돌아가야한다.
- 이를 통해 데이터의 일관상과 무결성을 유지한다.

### 트렌잭션의 ACID 속성
- Atomicity(원자성) : 트렌잭션의 모든 작업이 모두 성공하거나 모두 실패해야 한다.
- Consistency(일관성) : 트렌잭션 전후에 데이터베이스가 일관된 상태를 유지해아한다.
- Isolation(격리성) : 동시에 실행되는 트랜잭션들이 서로의 작업에 영향을 주지 않아야한다.
- Durability(지속성) : 트랜잭션이 커밋되면, 그 결과는 영구적으로 저장되어야 한다.

### SQL의 커밋과 롤백의 차이점
- COMMIT
  - 트렌젝션에서 수행한 변경 사항을 데이터베이스에 영구적으로 반영하는것
  - 트렌젝션이 성공적으로 완료되었음을 의미한다.
 
- ROLLBACK
  - 트랜젝션에서 수행한 모든 변경 사항을 취소하고 이전 상태로 되돌리는 것
  - 트랜젝션 중 오류가 발생하거나 명시적으로 취소하기 위해 사용하는 것
 
### SQL의 VIEW
- VIEW는 하나 이상의 테이블로 부터 유도된 가상의 테이블이다.
- VIEW는 실제 테이터를 저장하지 않고, 기본 테이블의 데이터를 기반으로 한다.

### VIEW와 테이블의 차이점
- 테이블
  - 테이블은 실제 데이터가 저장되는 곳이다.
  - 데이터베이스에서 테이블은 물리적으로 데이터를 보유하는 구조로, 데이터를 직접 추가, 삭제 ,수정이 가능
  - 테이블은 데이터베이스 내에서 영구적으로 존재한다.
- View
  - 실제 데이터가 저장되는 것이 아닌, 쿼리의 결과를 가상의 테이블 형태로 보여주는 객체이다.
  - 하나 이상의 테이블을 join하거나 필터링, 계산 등을 통해 동적으로 보여준다.
  - 뷰 자체에는 데이터를 저장하지 않고, 뷰를 호출할 때마다 원본 테이블에서 데이터를 조회한다.

### Stored Procedure의 목적을 설명하고 언제 사용하는지 예를 들어 설명하시오
- 데이터베이스에 저장된 SQL 문의 집합으로, 필요할 때 매개변수를 전달하여 실행할 수 있다.
- 코드 재사용, 성능 향상, 보안 강화 등의 이점이 있다.
- ex) 매월 말에 자동으로 실행되어 직원들의 급여를 계산하고 업데이트 하는 저장 프록시저를 만들 수 있다.

### 관계형 데이터베이스에서 트리거와 프로시저의 차이점
- 트리거
  - 특정 이벤트(INSERT, UPDATE, DELETE)가 발생할 때 자동으로 실행되는 sql 코드이다.
- 프로시저
  - 개발자가 명시적으로 호출하여 실행하는 sql코드의 집합이다.
  - 복잡한 연산, 업무 로직 구현 등에 사용된다.

### 외래 키의 제약조건
- 외래 키 제약 조건은 한 테이블의 외래 키가 참조하는 테이블의 기본 키와 일치해야 한다는 규칙을 강제한다.
- 이를 통해 데이터베이스에서 참조 무결성을 유지하고, 존재하지 않는 값을 참조하거나 관련된 데이터를 삭제하는
  등의 오류를 방지한다.

### 관계형 데이터베이스에서 NULL값을 처리하는 방법
- NULL은 데이터베이스에서 "알 수 없음" 또는 "값이 없다." 를 의미한다.
- NULL 값은 일반적인 비교 연산자(=, >, <)로 처리할 수 없으며, IS NULL, IS NOT NULL 연산자를 사용해야한다.
- 집계 함수나 연산 시 NULL 값을 주의 깊게 다뤄야 한다.
```
SELECT * FROM employees WHERE department_id IS NULL;
SELECT * FROM employees WHERE department_id IS NOT NULL;

```

## JAVA
### 객체 지향 프로그램
#
### JAVA에서 클래스와 객체의 차이점은?
- 클래스
  - 객체를 생성하기 위한 설계도 또는 툴 이다.
  - 필드(속성)와 메서드(동작)을 정의한다.
- 객체
  - 클래스를 기반으로 생성된 인스턴스이다.
  - 클래스에 정의된 속성과 동작을 실제로 사용할 수 있다.

### 생성자 (Constructor)
- 클래스의 새로운 객체를 생성하고 초기화하는데 사용되는 특별한 메서드이다.
- 클래스 이름과 동일하며 반환 타입이 없다.
- 객체 생성 시 자동으로 호출된다.

### 생성자의 사용 이유
1. 객체 초기화 : 생성자는 객체가 생성될 떄 필드를 초기화한다. 필드를 초기화하지 않으면 기본값으로 설정되지만,
               생성자를 사용하면 객체의 상태를 명확하게 정의할 수 있다. (기본값 : 숫자는 0, 참조형 null)
2. 객체 생성 시 필수 정보 설정 : 객체 생성 시 특정 필드나 설정이 반드시 필요할 때 생성자를 사용하여 해당 값을
   전달받을 수 있다. 필수적인 초기화 작업을 강제할 수 있어, 객체가 유효한 상태로 만들어지도록 보장한다.
3. 오버로딩을 통한 다양한 초기화 지원 : Java에서는 상성자 오버로딩을 통해 다양한 방식으로 객체를 초기화 할 수 있다. 동일한 이름을 갖지만 다른 매개변수를 갖는 여러 생성자를 정의하여, 객체를 사용자의 필요에 맞게 초기화 할 수 있다.
4. 불변 객체 생성(Immutable Object) : 생성자를 사용하면 객체의 필드를 초기화하고, 이후에는 값을 변경할 수 없도록 설정할 수 있다. 이를 통해 객체의 불변성을 보장할 수 있다.

### 메서드
- 객체가 수행항 수 있는 작업(동작,기능)을 정의한 코드 블록이다.
- 메서드는 특정 작업을 수행하기 위한 명령문의 집합이고, 재사용 가능한 코드 구조를 만드는데 중요한 역할을 한다.
- 메서드는 클래스 내에 정의되며, 객체의 행동을 나타낸다.
- 메서드는 메서드 이름, 반환 타입, 매개변수 목록, 메서드 본문 등이 포함된다.

### 메서드의 사용 이유
1. 코드의 재사용성 향상
 - 메서드를 사용하면 동일한 코드를 여러번 반복해서 작성하지 않아도 된다.
 - 공통적으로 수행하는 작어을 메서드로 정의하면, 필요할 떄 마다 해당 메서드를 호출하여 사용 가능하다.
2. 코드 가독성 향상
 - 메서드를 통해 코드의 목적을 명확히 할 수 있고, 각 메서드가 하나의 작업을 수행하도록 분리하면 프로그램의 구조가       깔끔해진다.
3. 유지보수 용이성
 - 특정 작업을 수행하는 코드를 메서드로 분리하면, 그 메서드만 수정하여 프로그램 전체의 동작을 쉽게 변경 가능하다.
 - 이를 통해 유지보수성과 확장성을 높일 수 있다.


